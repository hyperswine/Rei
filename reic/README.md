# Rei Compiler

Features of rei:

- pointers
  - references, basically safe auto pointers
    - parameterisation or pass by reference
    - immutable and explicit mutable references. Only one immutable reference at one time with no other references during mutable borrow
- operators
  - strict, defined order for simplicity and intuitiveness
  - operator overloading
  - bitwise ops
  - arithmetic math ops, BODMAS
- function calls
  - method calls
- pattern matching
  - enums
  - if else expr
  - ternary
    - elvis
- loop expr
  - for range or val in array/tuple
  - while bool expr
- arrow expressions
- strong typing
  - all types are first class citizens and treated similarly
  - overloading in the same scope, requires different signatures (mostly params)
  - universal definitions of types
    - generics
    - unsafe
      - by default, all types are safe in that they have no side effects
      - unsafe allows side effects and use of outer scoped mutable variables defined at module level
    - objects
      - key-val data
      - tagged union enums
      - inline subtyping with enum fields
      - object promotion and automatic base typing/sub enumming
      - methods, basically sugar so you dont have to type the whole thing
    - callables
      - functions
      - macros, hygenic and "builtin" with reic::macro_api auto linked. No quotes
        - annotations and global once type expr
      - tuples
    - shared functionality on types
      - traits and impls
  - primitive types
    - numeric of arbitrary precision based on specification
    - strings of character like types
      - interpolation with "{}"
    - arrays of a single type
- contracts
  - propagation, "comparison memory"
  - where clauses for types and generics
    - dependent types from contracts
      - arrays of static size
- algebraic effects
  - async/await, a pattern for concurrency (esp IO) and parallelism
  - yield and resume
- anonymous functions, type inference
- const, immutable and mutable variables, type inference based on literals and rhs
  - shadowing
  - mutation of value directly in memory location only possible with mut
- static and lazy variables
  - lazy and once initialised variables in a local scope, similar to consteval but at first use, after which the code is modified to use that directly. Usually dynamically allocated
- namespaced identifiers
  - use `<namespace ident>` semantics for importing
  - export `<universal def>` for exporting
    - default exports
    - exports to specific modules like pkg, prelude, super
- iterators
  - map, reduce, anonymous methods
  - parallel iterators with `.iter_parallel()`
- affine types
  - used only once
  - ownership, only one function may own a variable at once
  - release build basically uses linear types, all unused vars are eliminated
- result types
  - declared with `Result[T, E]`
  - optional types declared with T?
    - optional error types without an Ok value declared with T!
  - result propagation with `?` and `!`
